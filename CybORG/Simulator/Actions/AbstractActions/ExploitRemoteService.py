## The following code contains work of the United States Government and is not subject to domestic copyright protection under 17 USC ยง 105.
## Additionally, we waive copyright and related rights in the utilized code worldwide through the CC0 1.0 Universal public domain dedication.

from ipaddress import IPv4Address
from typing import Optional

from CybORG.Shared import Observation
from CybORG.Simulator.Actions.Action import RemoteAction
# Needs to be imported directly from the file to avoid circular import
from CybORG.Simulator.Actions.ConcreteActions.ExploitActions.ExploitAction import ExploitAction
from CybORG.Simulator.Actions.ConcreteActions.ExploitActions.BlueKeep import BlueKeep
from CybORG.Simulator.Actions.ConcreteActions.ExploitActions.EternalBlue import EternalBlue
from CybORG.Simulator.Actions.ConcreteActions.ExploitActions.HTTPRFI import HTTPRFI
from CybORG.Simulator.Actions.ConcreteActions.ExploitActions.HTTPSRFI import HTTPSRFI
from CybORG.Simulator.Actions.ConcreteActions.ExploitActions.SSHBruteForce import SSHBruteForce
from CybORG.Simulator.Actions.ConcreteActions.ExploitActions.FTPDirectoryTraversal import FTPDirectoryTraversal
from CybORG.Simulator.Actions.ConcreteActions.ExploitActions.SQLInjection import SQLInjection
from CybORG.Simulator.Actions.ConcreteActions.ExploitActions.HarakaRCE import HarakaRCE
from CybORG.Simulator.Actions.Action import lo
from CybORG.Shared.Session import RedAbstractSession
from CybORG.Simulator.State import State


# pylint: disable=too-few-public-methods
class ExploitActionSelector:
    """
    Examines the target host and returns a selected applicable escalate action
    if any, as well as processes that are required to be genuine
    """

    # pylint: disable=missing-function-docstring
    def get_exploit_action(self, *, state: State, session: int,
                           agent: str, ip_address: IPv4Address) -> Optional[ExploitAction]:
        raise NotImplementedError


class DefaultExploitActionSelector(ExploitActionSelector):
    """
    Chooses exploit based on available ports
    """

    def get_exploit_action(self, *, state: State, session: int,
                           agent: str, ip_address: IPv4Address, priority=None) -> Optional[ExploitAction]:
        ports = state.sessions[agent][session].ports[ip_address]
        # Weights need to be different. Should be refactored to a list.
        exploit_options = [
            EternalBlue, BlueKeep, # - never used in CC4 (kept for backwards-compatibility)
            HTTPRFI, HTTPSRFI, SSHBruteForce, SQLInjection, HarakaRCE,
            FTPDirectoryTraversal,
        ]
        weighted_options = { option: option.get_weight(ports) for option in exploit_options }
        weighted_options = { a: x for a, x in weighted_options.items() if x }
        if len(weighted_options) < 1:
            return
        selected_choice = list(weighted_options.keys())[0]
        if len(weighted_options) > 1:
            # use information to populate weights for which exploit to select
            odds_of_top_choice = 0
            top_choice = max(weighted_options, key=weighted_options.get)
            weighted_options.pop(top_choice)
            other_choice = state.np_random.choice(list(weighted_options.keys()))
            priority_value = weighted_options.get(priority)
            if priority_value is not None:
                selected_choice = priority_value
            elif state.np_random.random() < odds_of_top_choice:
                selected_choice = top_choice
            else:
                selected_choice = other_choice
        return selected_choice(session=session, agent=agent, ip_address=ip_address)


class PIDSelectiveExploitActionSelector(ExploitActionSelector):
    """
    Chooses exploit on available ports, but does not use specfic pids.
    """

    def __init__(self, excluded_pids):
        self.excluded_pids = excluded_pids

    def get_exploit_action(self, *, state: State, session: int,
                           agent: str, ip_address: IPv4Address) -> Optional[ExploitAction]:
        available_ports = state.sessions[agent][session].ports[ip_address]
        excluded_ports = []
        for process in state.hosts[state.ip_addresses[ip_address]].processes:
            if process.pid in self.excluded_pids:
                excluded_ports.append(process.open_ports['local_port'])
        
        ports = [port for port in available_ports if not port in excluded_ports]

        # Weights need to be different. Should be refactored to a list.
        exploit_options = [
            EternalBlue, BlueKeep, # - never used in CC4 (kept for backwards-compatibility)
            HTTPRFI, HTTPSRFI, SSHBruteForce, SQLInjection, HarakaRCE,
            FTPDirectoryTraversal,
        ]
        weighted_options = { option: option.get_weight(ports) for option in exploit_options }
        weighted_options = { a: x for a, x in weighted_options.items() if x }

        if len(weighted_options) < 1:
            return
        selected_choice = list(weighted_options.keys())[0]
        if len(weighted_options) > 1:
            # use information to populate weights for which exploit to select
            odds_of_top_choice = 0
            top_choice = max(weighted_options, key=weighted_options.get)
            weighted_options.pop(top_choice)
            other_choice = state.np_random.choice(list(weighted_options.keys()))
            priority_value = weighted_options.get(priority)
            if priority_value is not None:
                selected_choice = priority_value
            elif state.np_random.random() < odds_of_top_choice:
                selected_choice = top_choice
            else:
                selected_choice = other_choice
        return selected_choice(session=session, agent=agent, ip_address=ip_address)


class ExploitRemoteService(RemoteAction):
    """ 
    A Red action that attempts to exploit a service on a given host to gain a user privileged shell.

    Attributes
    ----------
    ip_address: IPv4Address
        The ip_address of the target host.
    session: int
        The source session id.
    agent: str
        The name of the red agent executing the action.
    exploit_action_selector: ExploitActionSelector
        A selector that chooses an applicable exploit for the target host, as well as required processes.
    """
    def __init__(self, ip_address: IPv4Address, session: int, agent: str):
        """ 
        Parameters
        ----------
        ip_address: IPv4Address
            The ip_address of the target host.
        session: int
            The source session id.
        agent: str
            The name of the red agent executing the action.
        """
        super().__init__(session, agent)
        self.ip_address = ip_address
        self.exploit_action_selector = DefaultExploitActionSelector()
        self.duration = 4

    def execute(self, state: State) -> Observation:
        """ 
        Attempts to exploit a service on the target host to gain a user privileged shell.

        Parameters
        ----------
        state: State
            The state of the simulated network at the current step.
        
        Returns
        -------
        obs: Observation
            An observation containing an indication of the action's successful execution as True/False, and the exploit carried out, if successful.
        """
        # find if agent session exists 
        session = state.sessions.get(self.agent, {}).get(self.session, None)
        if session is None:
            self.log(f"Session '{self.session}' for agent '{self.agent}' not found.")
            return Observation(success=False)
        src_hostname = session.hostname
        
        # check if session is of type RedAbstractSession
        if not isinstance(session, RedAbstractSession):
            self.log(f"Session type is '{type(session)}' not 'RedAbstractSession'.")
            return Observation(success=False)
        
        if self.ip_address not in session.ports:
            self.log(f"'{self.ip_address}' not found in session ports.")
            return Observation(success=False)

        # Check there are no blocks between the src and target hosts
        if self.blocking_host(state=state, src_hostname=src_hostname, other_hostname=state.ip_addresses[self.ip_address]):
            self.log(f"Traffic block between source '{state.hostname_ip_map[src_hostname]}' and target '{self.ip_address}'")
            return Observation(success=False)

        self.sub_action = self.exploit_action_selector.get_exploit_action(
            state=state,
            session=self.session,
            agent=self.agent,
            ip_address=self.ip_address,
            priority=self.priority
        )
        if self.sub_action is None:
            self.log(f"No valid exploit sub-action.")
            return Observation(success=False)
        
        self.sub_action.route = self.route
        obs = self.sub_action.execute(state)
        obs.add_raw_obs(f'Executed action {str(self.sub_action)}')
        if self.ip_address != lo and obs.data['success'] == True:
            hostname = obs.data[str(self.ip_address)]["System info"]["Hostname"]
            os = obs.data[str(self.ip_address)]["System info"]["OSType"]
            state.sessions[self.agent][self.session].addos(hostname, os)
        return obs

    def __str__(self):
        return f"{self.__class__.__name__} {self.ip_address}"

    def __eq__(self, other):
        if not isinstance(other, self.__class__):
            return False
        return all((
            self.name == other.name,
            self.ip_address == other.ip_address,
            self.agent == other.agent,
            self.session == other.session,
        ))

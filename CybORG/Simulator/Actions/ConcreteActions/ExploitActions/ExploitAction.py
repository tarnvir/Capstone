## The following code contains work of the United States Government and is not subject to domestic copyright protection under 17 USC ยง 105.
## Additionally, we waive copyright and related rights in the utilized code worldwide through the CC0 1.0 Universal public domain dedication.
"""
Pertaining to actions that establish a new session on a host by exploiting
a process on that host
"""
from ipaddress import IPv4Address
from typing import List

from CybORG.Shared import Observation
from CybORG.Simulator.Actions.Action import RemoteAction
from CybORG.Shared.Enums import ProcessType, OperatingSystemType, DecoyType
from CybORG.Simulator.File import File
from CybORG.Simulator.Host import Host
from CybORG.Simulator.HostEvents import NetworkConnection
from CybORG.Simulator.Process import Process
from CybORG.Shared.Session import Session
from CybORG.Simulator.State import State


class ExploitAction(RemoteAction):
    """
    Base class for actions that establish a new session on a host by exploiting
    a process on that host
    """

    PORT: int = None
    WEIGHT: float = 0.0

    def __init__(self, session: int, agent: str, ip_address: IPv4Address):
        super().__init__(session, agent)
        self.ip_address = ip_address
        self.detection_rate = 0.95
        self.success_rate = 1.

    @classmethod
    def get_weight(cls, ports: List[int]) -> float:
        return cls.WEIGHT if cls.PORT in ports else 0.0

    def get_used_route(self, state: State, refresh = True, routing = False) -> list:
        """finds the route used by the action and returns the hostnames along that route"""
        if refresh or not self.route_designated:
            target = state.ip_addresses[self.ip_address]
            source = state.sessions[self.agent][self.session].hostname
            self.route = self.get_route(state, target, source, routing)
        return self.route

    def sim_exploit(self, state: State, process_type: str) -> Observation:
        """Attempts to exploit host, establishing a session on it"""
        obs = Observation(False)
        if not(self.agent in state.sessions and self.session in state.sessions[self.agent]):
            return obs
        hostname = state.sessions[self.agent][self.session].hostname
        if self.dropped:
            return obs
        route = self.get_used_route(state, refresh=False)
        for other_hostname in route:
            host = state.hosts[other_hostname]
            remote_address = {h_name: ip_addr for ip_addr, h_name in state.ip_addresses.items()}[hostname]
            event = NetworkConnection(
                local_address=self.ip_address,
                remote_port=self.PORT,
                remote_address=remote_address
            )
            if other_hostname == self.blocked:
                host.events.network_connections.append(event)
                return obs
            # if 1 - self.detection_rate < state.np_random.random():
            #     # add even to hosts along the path if detection occurs
            #     host.events.network_connections.append(event)

        exploit_data = self._get_exploit_data(state, process_type)
        vuln_proc = exploit_data.get('vuln_proc')
        if vuln_proc is None:
            return obs

        target_process = self._get_target_process(process_type)
        obs.add_process(**target_process)

        exploit_works = self.test_exploit_works(**exploit_data)
        
        #When action fails
        if not exploit_works or (1 - self.success_rate) >= state.np_random.random():
            obs.add_interface_info(hostid=str(self.ip_address), ip_address=str(self.ip_address))
            return obs

        target_host: Host = exploit_data['target_host']
        
        local_port = target_host.get_ephemeral_port()
        is_exploit_decoy = bool(vuln_proc.decoy_type & DecoyType.EXPLOIT)
        if is_exploit_decoy:
            target_host.events.network_connections.append(NetworkConnection(
                local_address=self.ip_address,
                local_port=local_port,
                remote_address=exploit_data['from_ip'],
                remote_port=target_host.get_ephemeral_port()
            ))
            obs.add_interface_info(hostid=str(self.ip_address), ip_address=str(self.ip_address))
            return obs

        new_session = self._create_new_session(state, obs, local_port, **exploit_data)
        if state.np_random.random() > 1 - self.detection_rate:
            self._create_new_session_event(new_session, local_port, **exploit_data)

        session_info = self._get_session_info(new_session)
        obs.add_session_info(**session_info)

        source_conn, target_conn = self._get_connections(local_port, **exploit_data)
        obs.add_process(**source_conn)
        obs.add_process(**target_conn)

        system_info = self._get_system_info(target_host)
        obs.add_system_info(**system_info)
        obs.set_success(True)

        return obs

    def _get_exploit_data(self, state, process_type):
        '''
        Gets the data needed to carry out the exploit. Returns early if any data
        unavailable.
        '''
        exploit_data = {}

        exploit_data['session'] = session = self._get_active_session(state)
        if session is None:
            return exploit_data

        from_host = state.hosts[session.hostname]
        exploit_data['from_ip'] = self._get_originating_ip(state, from_host, \
                self.ip_address)
        if exploit_data['from_ip'] is None:
            return exploit_data

        exploit_data['hostname'] = hostname = state.ip_addresses.get(self.ip_address)
        if hostname is None:
            return exploit_data

        exploit_data['target_host'] = target_host = state.hosts[hostname]
        if target_host is None:
            return exploit_data

        extension, path = self._get_path_extension(target_host)
        exploit_data['extension'] = extension
        exploit_data['path'] = path
        if None in (extension, path):
            return exploit_data

        exploit_data['vuln_proc'] = vuln_proc = self._get_vulnerable_process(
                target_host, exploit_data['from_ip'], process_type)

        return exploit_data

    def _get_active_session(self, state):
        '''
        Gets the active session specified in the class constructor. Returns None if this
        can\'t be found.
        '''
        if self.agent not in state.sessions or self.session not in state.sessions[self.agent]:
            return None
        session = state.sessions[self.agent][self.session]
        if not session.active:
            return None
        return session

    def _get_path_extension(self, target_host):
        if target_host.os_type == OperatingSystemType.WINDOWS:
            ext = 'exe'
            path = 'C:\\temp\\'
        elif target_host.os_type == OperatingSystemType.LINUX:
            ext = 'sh'
            path = '/tmp/'
        else:
            ext = None
            path = None
        return ext, path

    def _get_vulnerable_process(self, target_host: Host, from_ip, process_type):
        '''
        Searches the state for the appropriate vulnerable process. Returns None if this \
                can\'t be found.
        '''
        parsed_proc_type = ProcessType.parse_string(process_type)
        vuln_proc = None
        for proc in target_host.processes:
            if proc.process_type == parsed_proc_type:
                for conn in proc.connections:
                    if conn.local_port == self.PORT:
                        vuln_proc = proc
                        if (not vuln_proc.decoy_type == DecoyType.NONE):
                            target_host.events.network_connections.append(NetworkConnection(
                                local_address=self.ip_address,
                                local_port=conn.local_port,
                                remote_address=from_ip,
                                remote_port=target_host.get_ephemeral_port()
                            ))
                        break
                if vuln_proc is not None:
                    break
        return vuln_proc

    def _get_target_process(self, process_type):
        target_process = {
            'hostid': str(self.ip_address),
            'local_address': self.ip_address,
            'local_port': self.PORT,
            'status': "open",
            'process_type': process_type
        }
        return target_process

    def _create_new_session(self, state: State, obs, local_port, session, from_ip, target_host: Host, \
            vuln_proc, extension, path, session_type='red_reverse_shell', **kwargs):
        source_connection = NetworkConnection(
            local_port=4444,
            application_protocol="tcp",
            local_address=from_ip,
            remote_address=self.ip_address,
            remote_port=local_port
        )
        source_process = state.hosts[session.hostname].get_process(session.pid)
        source_process.connections.append(source_connection)
        target_connection = NetworkConnection(
            local_port=local_port,
            application_protocol="tcp",
            remote_address=from_ip,
            remote_port=4444,
            local_address=self.ip_address
        )
        new_file = File(
            name=f'cmd.{extension}',
            path=path,
            user=target_host.get_user(vuln_proc.user),
            user_permissions=7,
            density=0.9,
            signed=False
        )
        target_host.files.append(new_file)
        proc = Process(
            pid=target_host.create_pid(),
            process_name=new_file.name,
            parent_pid=1,
            path=new_file.path,
            username=vuln_proc.user,
        )
        proc.connections.append(target_connection)
        target_host.processes.append(proc)

        is_sandbox = bool(vuln_proc.decoy_type & DecoyType.SANDBOXING_EXPLOIT)
        new_session = Session(
            ident=None,
            hostname=target_host.hostname,
            agent=self.agent,
            username=vuln_proc.user,
            session_type=session_type,
            parent=self.session,
            pid=proc.pid,
            is_escalate_sandbox=is_sandbox
        )
        state.add_session(new_session)

        return new_session

    def _create_new_session_event(self, new_session, local_port, from_ip, target_host: Host,\
            **kwargs):
        event = {
            'pid': new_session.pid,
            'Connections': [{
                'local_address': self.ip_address,
                'local_port': local_port,
                'remote_address': from_ip,
                'remote_port': 4444
            }]
        }
        target_host.events.process_creation.append(event)

    def _get_session_info(self, new_session):
        session_info = {
            'hostid': str(self.ip_address),
            'session_id': new_session.ident,
            'session_type': new_session.session_type,
            'agent': self.agent
        }
        return session_info

    def _get_connections(self, local_port, from_ip, **kwargs):
        source_connection = {
            'hostid': str(from_ip),
            'local_address': from_ip,
            'remote_address': str(self.ip_address),
            'local_port': 4444,
            'remote_port': local_port,
            'process_type': 'reverse_session_handler'
        }
        target_connection = {
            'hostid': str(self.ip_address),
            'local_address': str(self.ip_address),
            'remote_address': from_ip,
            'local_port': local_port,
            'remote_port': 4444,
            'process_type': 'reverse_session'
        }
        return source_connection, target_connection

    def _get_system_info(self, target_host):
        system_info = {
            'hostid': str(self.ip_address),
            'hostname': target_host.hostname,
            'os_type': target_host.os_type
        }
        return system_info

    def test_exploit_works(self, target_host: Host,
                           vuln_process: Process) -> bool:
        """
        check if OS and process information is correct for exploit to work.
        Return True if it will work given the vulnerable process vuln_process
        False otherwise
        """
        raise NotImplementedError
